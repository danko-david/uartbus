

Felépítmény:

Transmission control queue:
?	- mechanizmus ami biztosítja hogy a csomagok megérkeznek a vevő oldalra.

UART infrastruktúra:
Bus kapcsolat:
//	- Bus connector létrehozása
		- Mega-ra is kellene egy külön build, úgy látszik a soft-uart
			néha hibás adatot küld a host gépre. (Teszt)
//	- RPC szerver létrehozása
//	- CLI Bus console létrehozása
	- tranzakció azonoító foglaló, felszabadító rendszer.

Programozás:
	- egyéni build rendszer:
//		- első build: arduinó könyvtár, a könyvtárat egy objektum file-ba
//			foglaljuk össze.
		- amiben különböző build schemákat lehet létrehozni
		- ezeket egymás függőségeként meg lehet adni
			(Arduino & UB > UB_APP ) > APP
			
		- A reset és megszakítás kódrészt le kellene valahogy vágatni az
			szekció elejéről
		- Ebből HEX file-t állítunk elő.
		- Ezt felküldjük a bus-on keresztül a mikrovezérlőre.
		- CLI: ub upload -t 3 app.cpp


Bus Object API:
	- busz rendszerből egy azt reprezentáló objektumot képezzünk
		(Factory amiből eszköz objektumok hozhatóak létre)
	- A BusNodeObject-en biztosítson a bootloader funkcióinak hívhatóságát
	- a direkt hívás mellett lehessen tranzakciós módban is hívni.
	- Egyéni funkció hivási lehetőség:
		- tipusok támogatása: byte, int, short, char*, float



Bootloader TODO:
//	- illesszük közvetlenül az AVR-hez a kódot (UART és softUART-al)
//	- fordításnál meg lehessen adni egy eszközazonosítót
//	- a címzés mellett legyen alkalmazás névtér azonosító
//		- bus: UC újraindítása, broadcast forgadás segítségével autodiscovery
//		- bootloader: új program feltöltése, jelenlegi letöltése
//		- alkalmazás csomag fogadása és továbbítása
//	- pár busz funkció megalkotása:
//	- felülírható callback, alkalmazásnak szánt csomagok fogadására az
//		alkalmazás programban, illetve feladó függvény mellékelése ami a
//		bootloaderben foglal helyet
	- send queue
	- eszköz cím legyen átállítható.
	- funkciók exportálása a táblába (rand, manage_conntection, nyers küldés,
		master_dispatcher felülírása, eredeti master_dispatcher kezelő címe)
		megszakítás kezelő regisztrálása/funkciók kikérése
	- megszakítások gyüjtése és software-es elosztása

Arduino TODO:
	- Egyedi csomagolt címzés


BUS TODO:
	- helyes időzítések tesztelése (ping-pong oscilloscope rajzolata, 2 byte
		idő legyen csak kihagyva az kérés és a válasz között)
	- ütközés helyes kezelése (rand beépítése a host-ba)
	- megzavart adás újraküldése (teszt: egymást pingelő uc-k, kamu feladó
		csomag beszúrássa)
//	- adó buffer hozzáadaás
//	- feladásnál és vételnél mellékeljük/ellenőrizzük a CRC8-at
//	- ub_manage_connection-ból a visszaolvasást opcionálisra szervezzük ki,
//		ezt lehessen megszakításos üzemben is használni (arduino: serialEvent[,1,2,3])

--------
	Arduino UARTBUS (struct arduino_uartbus testesíti meg)
		Stream adható meg neki amibe ír, ez lehet a Serial[,1,2,3]
	vagy
		TODO SoftwareSerial
--------	
	UARTBUS (struct uartbus testesíti meg)


Funkciók:
	- ping
	- ub_host változó lekérés (sos, run_app, )
	- ub_host változó frissítés (-||-)
	- újraindítás
	- reset
	- has_app
	- konstans lekérése (APP_START, MAX_PACKET_SIZE, DEV_ID, DEV_UUID)
	- funkció mutató lekérése
	- flash funkciók (írás, commit, kód memórai lekérése)
	- {spec regiszter, ram} {olvasása, írása}
	- tranzakciós kérés (wrap)
	

--------------------------------------------------------------------------------

Szakdogában említendő:
	- 4 KB-ba bele kellene férni
	
	- A PIC-ek sokkal kisebb programtárral rendelkeznek az AVR-hez képest, és
		ez utóbbi olcsóbb is.
		
	- a malloc/free sok területet foglal el a pgoramtárban (TODO mennyit),
		ezeket mellőzöm

	- Az app-nak páros címre igazítva kell lennie.

	- Én big endiant használok (hálózati bájtsorrend), míg az AVR little-t így
		a structure packet_structure beolvasás nem működik.
		//https://stackoverflow.com/questions/13514614/why-is-network-byte-order-defined-to-be-big-endian

	- A prototipusnál 0:0:1:0 formában adtam parancsokat.
	
	- Kódolási stílus (NASA szerű standard)
	
	- A dispatchelés az SNMP MIB-jeihez hasoló
	
	- Első app tesz kód:     8FEF84B985B1809585B90895 //DDRB=0xff;PORTB ^=0xff;return;return;

Optimalizáció:
	- Az AVR-gcc az -Os ellenére túl inline-osítja a sorokat ezzel nagyobb kódot
		eredményezve, (TODO hogyan optimalizáltam, .asm és .sizes)
	
	- Nincs FPU, ezért az osztás és a szorzást nagy különálló kódrész végzi amit
		ezért ezeket ki kell váltani a kódból.
		- a timeout ciklust statikusan, fordítás időben számíttatom.
		- a fairwait ciklusok száma alkalom helyett mód kapcsoló lett.

Bootloader pitfalls:
	- A flash-t író kódnak a bootloader területén kell lennie.
		(nincs különleges mód stb, csak a kód elhelyezkedése)
	- Az boot_spm_busy_wait-et nem szabad elmulasztani, ez meghiúsítja a beírást
	- Ha már van bootloader section-ünk, akkor az elejére ugró kódot kell rakni,
		mivel a resetelés ide adja a vezérlést és beleakadhat egy író funkcióba
			rossz "paraméterekkel" (undefined behavior)
	- Nem lehet az író lapot részletekben feltölteni.
		Csak belekerült az a malloc/free

//folyamat:
	- belépés bootloader módba: 2:4:1
		- válasz: 2:4:1:0
	- köv lap lekérdezése: 2:4:2

		
	- lap kiírása: 2:4:3:$addess:$data
		- 2:4:3:48:0:143:239:132:185:133:177:128:149:133:185:8:149
		- empty: 2:4:3:48:0:255:255:255:255:255:255:255:255:255:255:255:255
		- válasz: 2:4:3:0:$next_address
	- commit 2:4:4
		- run app:
//			- disable sos 2:2:1:0
			- enable app 2:2:0:1
	- reboot (light reset) 2:0:1


- b_get_var: 2:1:(0 = app_run, 1=sos)
- b_set_var: 2:2: -||-:val
- soft_reboot: 2:0:1
- wdt_reboot: 2:0:0


-lap lekérdezése: 2:3:$addr:$size
(0x0000)	- 2:3:0:0:16
(0x3000)	- 2:3:48:0:16
(0x5000)	- 2:3:80:0:16


- 34:0:0:16
- 34:48:0:16
- 34:80:0:16
- 33:1:2:3:4:5:6:7:8:9

2:4:1
2:4:3:48:0:143:239:132:185:133:177:128:149:133:185:8:149
2:3:48:0:16
